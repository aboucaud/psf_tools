{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the PSF tools API documentation \u00b6 psftools is a personal library of utility methods to deal with astronomical point spread functions (PSFs). In particular one finds methods to analyse the characteristics of a PSF such as its encircled energy, azimuthal profiles, ellipticity, etc., and perform classical operations on them such a normalisation, conversion to Fourier domain, convolutions, etc. The library installs two convenient scripts: - make_kernel to compute a homogenization kernel from one PSF image to a broader one (not handling actual deconvolution) - homogenization to apply these kernels on astronomical images to perform PSF matching. It has been mainly developed at Institut d'Astrophysique Spatiale (2014-2016) and was rejuvenated in May 2023 to deal with current Python standards and prepare its release on GitHub.","title":"Home"},{"location":"index.html#welcome-to-the-psf-tools-api-documentation","text":"psftools is a personal library of utility methods to deal with astronomical point spread functions (PSFs). In particular one finds methods to analyse the characteristics of a PSF such as its encircled energy, azimuthal profiles, ellipticity, etc., and perform classical operations on them such a normalisation, conversion to Fourier domain, convolutions, etc. The library installs two convenient scripts: - make_kernel to compute a homogenization kernel from one PSF image to a broader one (not handling actual deconvolution) - homogenization to apply these kernels on astronomical images to perform PSF matching. It has been mainly developed at Institut d'Astrophysique Spatiale (2014-2016) and was rejuvenated in May 2023 to deal with current Python standards and prepare its release on GitHub.","title":"Welcome to the PSF tools API documentation"},{"location":"api/core.html","text":"Core class \u00b6 Core submodule \u00b6 ImageFits \u00b6 Base class for handling FITS images Parameters: input ( str, list or numpy.ndarray ) \u2013 Path to the image FITS file or image data pixel_scale ( float, optional (default 0.0) ) \u2013 Pixel scale of input image data in arcseconds backup ( bool, optional (default ) \u2013 Create a backup when loading the data verbose ( bool, optional (default ) \u2013 Add some verbosity to the actions Attributes: filename ( str ) \u2013 Path to the image FITS file image ( array_like ) \u2013 Image data cube header ( `fits.Header` ) \u2013 Image header image_fft ( array_like ) \u2013 Array of the Fourier transform of the images verbose ( bool ) \u2013 If True , print debug messages _image_copy ( array_like , optional ) \u2013 Backup image _header_copy ( `fits.Header`, optional ) \u2013 Backup header header property writable \u00b6 Return current kernel image property writable \u00b6 The current image image_fft property writable \u00b6 Return the Fourier transform of the current image image_fft_shift property \u00b6 Return the shifted Fourier transform of the image pixel_scale property \u00b6 Retrieve the pixel scale in the image in arcseconds shape property \u00b6 Return a tuple of kernel size in x and y axes compute_fft ( real = False ) \u00b6 Perform an Fourier transform of the current image compute_ifft ( real = False ) \u00b6 Perform an inverse Fourier transform of the current image delete_header_key ( key ) \u00b6 Delete a given key of the image header get_copy ( header = False ) \u00b6 Return the copy of the original image Parameters: header ( bool , optional ) \u2013 If True , returns the header copy as well (default False ) Returns: tuple ( \u2013 Returned only if header is True . A single numpy.ndarray is returned otherwise. load_data ( pixel_scale , backup ) \u00b6 Load kernel and header from external file and store a copy Parameters: pixel_scale ( float ) \u2013 Pixel scale of input image data in arcseconds backup ( bool ) \u2013 Create a backup when loading the data make_copy () \u00b6 Store a copy of the input kernel and header restore_initial_data () \u00b6 Replace current kernel and header by original version save_image ( filename ) \u00b6 Save the current image with its header in a FITS file Parameters: filename ( str ) \u2013 Path where to save the image save_plot ( filepath , fft = False , log = False , tridim = False , cmap = 'coolwarm' , fplot = 'norm' ) \u00b6 Creates plot of the current image Parameters: filepath ( str ) \u2013 Output file path fft ( bool , optional ) \u2013 If True , plot the fft image rather than the real space one (default False) log ( bool , optional ) \u2013 If True , plot the log scaled intensity (default False) tridim ( bool , optional ) \u2013 If True , renders as 3d instead of 2d (default False) cmap \u2013 Colormap for the plot fplot \u2013 If fft is True , defines which complex component to plot * norm Norm of the FT, \\sqrt(real 2 + imag 2) (default) * real Real part of the FT * imag Imaginary part of the FT update_header_comment ( key , comment ) \u00b6 Update of add a given key of the image header update_header_key ( key , value ) \u00b6 Update of add a given key of the image header","title":"core"},{"location":"api/core.html#core-class","text":"","title":"Core class"},{"location":"api/core.html#psftools.classes.core--core-submodule","text":"","title":"Core submodule"},{"location":"api/core.html#psftools.classes.core.ImageFits","text":"Base class for handling FITS images Parameters: input ( str, list or numpy.ndarray ) \u2013 Path to the image FITS file or image data pixel_scale ( float, optional (default 0.0) ) \u2013 Pixel scale of input image data in arcseconds backup ( bool, optional (default ) \u2013 Create a backup when loading the data verbose ( bool, optional (default ) \u2013 Add some verbosity to the actions Attributes: filename ( str ) \u2013 Path to the image FITS file image ( array_like ) \u2013 Image data cube header ( `fits.Header` ) \u2013 Image header image_fft ( array_like ) \u2013 Array of the Fourier transform of the images verbose ( bool ) \u2013 If True , print debug messages _image_copy ( array_like , optional ) \u2013 Backup image _header_copy ( `fits.Header`, optional ) \u2013 Backup header","title":"ImageFits"},{"location":"api/core.html#psftools.classes.core.ImageFits.header","text":"Return current kernel","title":"header"},{"location":"api/core.html#psftools.classes.core.ImageFits.image","text":"The current image","title":"image"},{"location":"api/core.html#psftools.classes.core.ImageFits.image_fft","text":"Return the Fourier transform of the current image","title":"image_fft"},{"location":"api/core.html#psftools.classes.core.ImageFits.image_fft_shift","text":"Return the shifted Fourier transform of the image","title":"image_fft_shift"},{"location":"api/core.html#psftools.classes.core.ImageFits.pixel_scale","text":"Retrieve the pixel scale in the image in arcseconds","title":"pixel_scale"},{"location":"api/core.html#psftools.classes.core.ImageFits.shape","text":"Return a tuple of kernel size in x and y axes","title":"shape"},{"location":"api/core.html#psftools.classes.core.ImageFits.compute_fft","text":"Perform an Fourier transform of the current image","title":"compute_fft()"},{"location":"api/core.html#psftools.classes.core.ImageFits.compute_ifft","text":"Perform an inverse Fourier transform of the current image","title":"compute_ifft()"},{"location":"api/core.html#psftools.classes.core.ImageFits.delete_header_key","text":"Delete a given key of the image header","title":"delete_header_key()"},{"location":"api/core.html#psftools.classes.core.ImageFits.get_copy","text":"Return the copy of the original image Parameters: header ( bool , optional ) \u2013 If True , returns the header copy as well (default False ) Returns: tuple ( \u2013 Returned only if header is True . A single numpy.ndarray is returned otherwise.","title":"get_copy()"},{"location":"api/core.html#psftools.classes.core.ImageFits.load_data","text":"Load kernel and header from external file and store a copy Parameters: pixel_scale ( float ) \u2013 Pixel scale of input image data in arcseconds backup ( bool ) \u2013 Create a backup when loading the data","title":"load_data()"},{"location":"api/core.html#psftools.classes.core.ImageFits.make_copy","text":"Store a copy of the input kernel and header","title":"make_copy()"},{"location":"api/core.html#psftools.classes.core.ImageFits.restore_initial_data","text":"Replace current kernel and header by original version","title":"restore_initial_data()"},{"location":"api/core.html#psftools.classes.core.ImageFits.save_image","text":"Save the current image with its header in a FITS file Parameters: filename ( str ) \u2013 Path where to save the image","title":"save_image()"},{"location":"api/core.html#psftools.classes.core.ImageFits.save_plot","text":"Creates plot of the current image Parameters: filepath ( str ) \u2013 Output file path fft ( bool , optional ) \u2013 If True , plot the fft image rather than the real space one (default False) log ( bool , optional ) \u2013 If True , plot the log scaled intensity (default False) tridim ( bool , optional ) \u2013 If True , renders as 3d instead of 2d (default False) cmap \u2013 Colormap for the plot fplot \u2013 If fft is True , defines which complex component to plot * norm Norm of the FT, \\sqrt(real 2 + imag 2) (default) * real Real part of the FT * imag Imaginary part of the FT","title":"save_plot()"},{"location":"api/core.html#psftools.classes.core.ImageFits.update_header_comment","text":"Update of add a given key of the image header","title":"update_header_comment()"},{"location":"api/core.html#psftools.classes.core.ImageFits.update_header_key","text":"Update of add a given key of the image header","title":"update_header_key()"},{"location":"api/psf.html","text":"PSF class \u00b6 PSF submodule \u00b6 Class handling PSF FITS image and header and various operations on them. PSF \u00b6 Bases: ImageFits Subclass of ImageFits for handling PSF images Parameters: filename ( str ) \u2013 Path to the image FITS file pixel_scale ( float, optional (default 0.0) ) \u2013 Pixel scale of input image data in arcseconds backup ( bool ) \u2013 Create a backup when loading the data verbose ( bool , optional ) \u2013 Add some verbosity to the actions Attributes: filename ( str ) \u2013 Path to the image FITS file image ( array_like ) \u2013 Image data cube header ( `fits.Header` ) \u2013 Image header image_fft ( array_like ) \u2013 Array of the Fourier transform of the images fwhm ( float ) \u2013 The FWHM value of the PSF verbose ( bool ) \u2013 If True , print debug messages _image_copy ( array_like , optional ) \u2013 Backup image if backup= True _header_copy ( `fits.Header`, optional ) \u2013 Backup header if backup= True _circularized ( bool ) \u2013 If True , indicates the image has already been circularized center_distance property \u00b6 Return the euclidian pixel distance to the array center fwhm property writable \u00b6 Return the FWHM (Full Width at Half Maximum) of the PSF is_centered property \u00b6 Return True if central pixel corresponds to the PSF peak is_circularized property \u00b6 Return True if the image has not been modified since last circularization is_square property \u00b6 Return True if the image array is a square center_psf () \u00b6 Shift the image to put the maximum at the center circularize ( log = False ) \u00b6 Apply a circularization procedure to the image Parameters: log \u2013 If True , compute the circularization in log space (default False) circularize_fft () \u00b6 Circularize the Fourier transform of the PSF circularize_fft_aniano ( n_itermax = 14 , interp_order = 2 ) \u00b6 Circularize the Fourier transform of the PSF circularize_fft_chanial () \u00b6 Circularize FT image using the 2D projection of its profile circularize_psf_aniano ( n_itermax = 14 , interp_order = 2 , log = True , correction = False ) \u00b6 \" Aniano circularization procedure We successively rotate the image and add it to itself with angles decreasing by a factor 2 every iteration. This is numerically equivalent to computing the average over 2^n rotations where n is the number of iterations. The default choice of n=14 hence produces a PSF invariant under rotations of any angle that is a multiple of 360/2^14 = 360/16384 ~ 0.022 deg Parameters: n_itermax ( int , optional ) \u2013 Number of performed rotational iterations (default 14) interp_order ( int , optional ) \u2013 Order of spline interpolation (default 2 = cubic) log \u2013 If True , compute the circularization in log space (default True) correction \u2013 If True , measures the distortion induced by the circularization and apply it back to the array (default False ) circularize_psf_chanial () \u00b6 Circularize image using the 2D projection of its profile clean_circle () \u00b6 Clean image outside of inner circle clean_threshold ( thresh = THRESH_VAL ) \u00b6 Clean image under a certain threshold correct_wings ( r_min , r_max , r_study , n_itermax = 10 ) \u00b6 Fit a model to the wings of the PSF and add it to the core image Parameters: r_min \u2013 Lower bound in radius r_max \u2013 Upper bound in radius r_study \u2013 Transition radius n_itermax \u2013 Number of iterations for the fitting process filter_fft () \u00b6 Low-pass filter to remove high frequency components in the Fourier transform of the kernels Notes \u00b6 The high frequency cut k_hf = 4 x 2pi / FWHM has been found empirically by Aniano et al. 2011 get_inverse_fft_image () \u00b6 The inverse of the Fourier image. In order to avoid infinites in the output array, we set to zero all the output values that correspond to input values whose norm is less that 1.e-7 times the peak value. Returns: fft_inverse ( complex ) \u2013 The inverse of the current Fourier image Notes \u00b6 The high frequency cut-off for the smooth filter is determined as the frequency above which FT PSF < 5.0e-3 max(FT[PSF]) make_odd_square ( size = 0 ) \u00b6 Pad kernel to get a square image of odd side size A given size can be optionnally input Parameters: size \u2013 A size to pad the image normalize ( to_max = False ) \u00b6 Kernel normalization Parameters: to_max \u2013 If true, normalize to the maximum value in the array (default False) plot_fft ( outpng = '' ) \u00b6 Show the Fourier transform of the image in decimal log space plot_fft_profile ( real = False , outpng = '' ) \u00b6 Plot the radial profile of the Fourier transform of the PSF plot_image ( outpng = '' , colorbar = True , axes = True , trans = False ) \u00b6 Show the image in decimal log space plot_profile ( outpng = '' ) \u00b6 Plot the radial profile of the PSF resample ( new_pixel_scale , interp_order = 2 ) \u00b6 Resample kernel to a given pixel scale Parameters: new_pixel_scale ( float ) \u2013 Pixel scale in arcseconds to which resample the kernel interp_order ( int , optional ) \u2013 Spline interpolation order [0, 5] (default 2: cubic) resize ( new_size ) \u00b6 Resize the PSF without resampling Warning: Can lead to a loss of information if used unproperly ! Make sure the new size has a meaning Parameters: new_size \u2013 Output size of the image rotate ( angle ) \u00b6 Rotate image from North to East given the angle in degrees Parameters: angle \u2013 Angle in degrees","title":"psf"},{"location":"api/psf.html#psf-class","text":"","title":"PSF class"},{"location":"api/psf.html#psftools.classes.psf--psf-submodule","text":"Class handling PSF FITS image and header and various operations on them.","title":"PSF submodule"},{"location":"api/psf.html#psftools.classes.psf.PSF","text":"Bases: ImageFits Subclass of ImageFits for handling PSF images Parameters: filename ( str ) \u2013 Path to the image FITS file pixel_scale ( float, optional (default 0.0) ) \u2013 Pixel scale of input image data in arcseconds backup ( bool ) \u2013 Create a backup when loading the data verbose ( bool , optional ) \u2013 Add some verbosity to the actions Attributes: filename ( str ) \u2013 Path to the image FITS file image ( array_like ) \u2013 Image data cube header ( `fits.Header` ) \u2013 Image header image_fft ( array_like ) \u2013 Array of the Fourier transform of the images fwhm ( float ) \u2013 The FWHM value of the PSF verbose ( bool ) \u2013 If True , print debug messages _image_copy ( array_like , optional ) \u2013 Backup image if backup= True _header_copy ( `fits.Header`, optional ) \u2013 Backup header if backup= True _circularized ( bool ) \u2013 If True , indicates the image has already been circularized","title":"PSF"},{"location":"api/psf.html#psftools.classes.psf.PSF.center_distance","text":"Return the euclidian pixel distance to the array center","title":"center_distance"},{"location":"api/psf.html#psftools.classes.psf.PSF.fwhm","text":"Return the FWHM (Full Width at Half Maximum) of the PSF","title":"fwhm"},{"location":"api/psf.html#psftools.classes.psf.PSF.is_centered","text":"Return True if central pixel corresponds to the PSF peak","title":"is_centered"},{"location":"api/psf.html#psftools.classes.psf.PSF.is_circularized","text":"Return True if the image has not been modified since last circularization","title":"is_circularized"},{"location":"api/psf.html#psftools.classes.psf.PSF.is_square","text":"Return True if the image array is a square","title":"is_square"},{"location":"api/psf.html#psftools.classes.psf.PSF.center_psf","text":"Shift the image to put the maximum at the center","title":"center_psf()"},{"location":"api/psf.html#psftools.classes.psf.PSF.circularize","text":"Apply a circularization procedure to the image Parameters: log \u2013 If True , compute the circularization in log space (default False)","title":"circularize()"},{"location":"api/psf.html#psftools.classes.psf.PSF.circularize_fft","text":"Circularize the Fourier transform of the PSF","title":"circularize_fft()"},{"location":"api/psf.html#psftools.classes.psf.PSF.circularize_fft_aniano","text":"Circularize the Fourier transform of the PSF","title":"circularize_fft_aniano()"},{"location":"api/psf.html#psftools.classes.psf.PSF.circularize_fft_chanial","text":"Circularize FT image using the 2D projection of its profile","title":"circularize_fft_chanial()"},{"location":"api/psf.html#psftools.classes.psf.PSF.circularize_psf_aniano","text":"\" Aniano circularization procedure We successively rotate the image and add it to itself with angles decreasing by a factor 2 every iteration. This is numerically equivalent to computing the average over 2^n rotations where n is the number of iterations. The default choice of n=14 hence produces a PSF invariant under rotations of any angle that is a multiple of 360/2^14 = 360/16384 ~ 0.022 deg Parameters: n_itermax ( int , optional ) \u2013 Number of performed rotational iterations (default 14) interp_order ( int , optional ) \u2013 Order of spline interpolation (default 2 = cubic) log \u2013 If True , compute the circularization in log space (default True) correction \u2013 If True , measures the distortion induced by the circularization and apply it back to the array (default False )","title":"circularize_psf_aniano()"},{"location":"api/psf.html#psftools.classes.psf.PSF.circularize_psf_chanial","text":"Circularize image using the 2D projection of its profile","title":"circularize_psf_chanial()"},{"location":"api/psf.html#psftools.classes.psf.PSF.clean_circle","text":"Clean image outside of inner circle","title":"clean_circle()"},{"location":"api/psf.html#psftools.classes.psf.PSF.clean_threshold","text":"Clean image under a certain threshold","title":"clean_threshold()"},{"location":"api/psf.html#psftools.classes.psf.PSF.correct_wings","text":"Fit a model to the wings of the PSF and add it to the core image Parameters: r_min \u2013 Lower bound in radius r_max \u2013 Upper bound in radius r_study \u2013 Transition radius n_itermax \u2013 Number of iterations for the fitting process","title":"correct_wings()"},{"location":"api/psf.html#psftools.classes.psf.PSF.filter_fft","text":"Low-pass filter to remove high frequency components in the Fourier transform of the kernels","title":"filter_fft()"},{"location":"api/psf.html#psftools.classes.psf.PSF.filter_fft--notes","text":"The high frequency cut k_hf = 4 x 2pi / FWHM has been found empirically by Aniano et al. 2011","title":"Notes"},{"location":"api/psf.html#psftools.classes.psf.PSF.get_inverse_fft_image","text":"The inverse of the Fourier image. In order to avoid infinites in the output array, we set to zero all the output values that correspond to input values whose norm is less that 1.e-7 times the peak value. Returns: fft_inverse ( complex ) \u2013 The inverse of the current Fourier image","title":"get_inverse_fft_image()"},{"location":"api/psf.html#psftools.classes.psf.PSF.get_inverse_fft_image--notes","text":"The high frequency cut-off for the smooth filter is determined as the frequency above which FT PSF < 5.0e-3 max(FT[PSF])","title":"Notes"},{"location":"api/psf.html#psftools.classes.psf.PSF.make_odd_square","text":"Pad kernel to get a square image of odd side size A given size can be optionnally input Parameters: size \u2013 A size to pad the image","title":"make_odd_square()"},{"location":"api/psf.html#psftools.classes.psf.PSF.normalize","text":"Kernel normalization Parameters: to_max \u2013 If true, normalize to the maximum value in the array (default False)","title":"normalize()"},{"location":"api/psf.html#psftools.classes.psf.PSF.plot_fft","text":"Show the Fourier transform of the image in decimal log space","title":"plot_fft()"},{"location":"api/psf.html#psftools.classes.psf.PSF.plot_fft_profile","text":"Plot the radial profile of the Fourier transform of the PSF","title":"plot_fft_profile()"},{"location":"api/psf.html#psftools.classes.psf.PSF.plot_image","text":"Show the image in decimal log space","title":"plot_image()"},{"location":"api/psf.html#psftools.classes.psf.PSF.plot_profile","text":"Plot the radial profile of the PSF","title":"plot_profile()"},{"location":"api/psf.html#psftools.classes.psf.PSF.resample","text":"Resample kernel to a given pixel scale Parameters: new_pixel_scale ( float ) \u2013 Pixel scale in arcseconds to which resample the kernel interp_order ( int , optional ) \u2013 Spline interpolation order [0, 5] (default 2: cubic)","title":"resample()"},{"location":"api/psf.html#psftools.classes.psf.PSF.resize","text":"Resize the PSF without resampling Warning: Can lead to a loss of information if used unproperly ! Make sure the new size has a meaning Parameters: new_size \u2013 Output size of the image","title":"resize()"},{"location":"api/psf.html#psftools.classes.psf.PSF.rotate","text":"Rotate image from North to East given the angle in degrees Parameters: angle \u2013 Angle in degrees","title":"rotate()"},{"location":"api/utils/analysis.html","text":"Analysis submodule \u00b6 Set of methods to evaluate the profile of the PSF circ_psd ( image , sampling_freq = 1 , plot = False ) \u00b6 Profile of the Fourier PSD of a 2d array. Computes the azimuthal profile of the Fourier power spectral density of the image, along with the corresponding Fourier modes. This allows the visualization of the cutting frequency of a 2d filter for example. Parameters: image \u2013 Image array sampling_freq ( float, optional (default ) \u2013 The sampling frequency. plot ( bool, optional (default ) \u2013 If True , draws the PSD w.r.t. radius in log scale Returns: radius ( 1D ) \u2013 Radius vector psd ( 1D ) \u2013 Circular power spectral density get_radius_old ( value , distance , profile ) \u00b6 Return the radius corresponding to the input profile value Parameters: value \u2013 Profile value which the radius is wanted distance \u2013 Radius grid profile \u2013 Image profile Returns: radius ( float ) \u2013 Distance at which the profile matches the input value (same dimensionality of the distance input array) Remarks \u00b6 Only works for a monotonious profile integrated_profile ( input , origin = None , bin = 1.0 , nbins = None ) \u00b6 Returns axisymmetric integrated profile of a 2d image. Parameters: input \u2013 2d input array. origin \u2013 Center of the profile. Default is the image center. bin \u2013 width of the profile bins (in unit of pixels). nbins \u2013 number of profile bins. Returns: x ( numpy . ndarray ) \u2013 The strict upper boundary within which each integration is performed. y ( numpy . ndarray ) \u2013 The integrated profile. profile ( input , origin = None , bin = 1.0 , nbins = None , histogram = False ) \u00b6 Returns axisymmetric profile of a 2d image. x, y[, n] = profile(image, [origin, bin, nbins, histogram]) Parameters: input \u2013 2D input array origin \u2013 Center of profile (Fits convention) bin \u2013 Width of the profile bins (in unit of pixels). nbins \u2013 Number of profile bins. histogram \u2013 If True , returns the histogram. Returns: radius \u2013 Profile radius in unit of pixels profile \u2013 Profile of input array [histo \u2013 Histogram of pixel count in each bin] Note \u00b6 This method and the underlying azimuthal_profile function have been adapted from the pysimulators package written by P.Chanial. slow_azimuthal_profile ( image , origin , bin , n_bins ) \u00b6 Azimuthal profile of a 2d image. x, y[, n] = profile(image, [origin, bin, n_bins, histogram]) Parameters: image \u2013 2D input array origin ( tuple of float ) \u2013 Center of profile (Fits convention) bin ( float ) \u2013 Width of the profile bins (in unit of pixels). n_bins ( int ) \u2013 Number of profile bins. Returns: radius \u2013 Profile radius in unit of pixels profile \u2013 Profile of input array histo \u2013 Histogram of pixel count in each bin slow_get_radius ( value , distance , profile ) \u00b6 Return the radius corresponding to the input profile value Parameters: value \u2013 Profile value which the radius is wanted distance \u2013 Radius grid profile \u2013 Image profile Returns: radius ( float ) \u2013 Distance at which the profile matches the input value (same dimensionality of the distance input array) Remarks \u00b6 Only works for a monotonious profile","title":"analysis"},{"location":"api/utils/analysis.html#psftools.utils.analysis--analysis-submodule","text":"Set of methods to evaluate the profile of the PSF","title":"Analysis submodule"},{"location":"api/utils/analysis.html#psftools.utils.analysis.circ_psd","text":"Profile of the Fourier PSD of a 2d array. Computes the azimuthal profile of the Fourier power spectral density of the image, along with the corresponding Fourier modes. This allows the visualization of the cutting frequency of a 2d filter for example. Parameters: image \u2013 Image array sampling_freq ( float, optional (default ) \u2013 The sampling frequency. plot ( bool, optional (default ) \u2013 If True , draws the PSD w.r.t. radius in log scale Returns: radius ( 1D ) \u2013 Radius vector psd ( 1D ) \u2013 Circular power spectral density","title":"circ_psd()"},{"location":"api/utils/analysis.html#psftools.utils.analysis.get_radius_old","text":"Return the radius corresponding to the input profile value Parameters: value \u2013 Profile value which the radius is wanted distance \u2013 Radius grid profile \u2013 Image profile Returns: radius ( float ) \u2013 Distance at which the profile matches the input value (same dimensionality of the distance input array)","title":"get_radius_old()"},{"location":"api/utils/analysis.html#psftools.utils.analysis.get_radius_old--remarks","text":"Only works for a monotonious profile","title":"Remarks"},{"location":"api/utils/analysis.html#psftools.utils.analysis.integrated_profile","text":"Returns axisymmetric integrated profile of a 2d image. Parameters: input \u2013 2d input array. origin \u2013 Center of the profile. Default is the image center. bin \u2013 width of the profile bins (in unit of pixels). nbins \u2013 number of profile bins. Returns: x ( numpy . ndarray ) \u2013 The strict upper boundary within which each integration is performed. y ( numpy . ndarray ) \u2013 The integrated profile.","title":"integrated_profile()"},{"location":"api/utils/analysis.html#psftools.utils.analysis.profile","text":"Returns axisymmetric profile of a 2d image. x, y[, n] = profile(image, [origin, bin, nbins, histogram]) Parameters: input \u2013 2D input array origin \u2013 Center of profile (Fits convention) bin \u2013 Width of the profile bins (in unit of pixels). nbins \u2013 Number of profile bins. histogram \u2013 If True , returns the histogram. Returns: radius \u2013 Profile radius in unit of pixels profile \u2013 Profile of input array [histo \u2013 Histogram of pixel count in each bin]","title":"profile()"},{"location":"api/utils/analysis.html#psftools.utils.analysis.profile--note","text":"This method and the underlying azimuthal_profile function have been adapted from the pysimulators package written by P.Chanial.","title":"Note"},{"location":"api/utils/analysis.html#psftools.utils.analysis.slow_azimuthal_profile","text":"Azimuthal profile of a 2d image. x, y[, n] = profile(image, [origin, bin, n_bins, histogram]) Parameters: image \u2013 2D input array origin ( tuple of float ) \u2013 Center of profile (Fits convention) bin ( float ) \u2013 Width of the profile bins (in unit of pixels). n_bins ( int ) \u2013 Number of profile bins. Returns: radius \u2013 Profile radius in unit of pixels profile \u2013 Profile of input array histo \u2013 Histogram of pixel count in each bin","title":"slow_azimuthal_profile()"},{"location":"api/utils/analysis.html#psftools.utils.analysis.slow_get_radius","text":"Return the radius corresponding to the input profile value Parameters: value \u2013 Profile value which the radius is wanted distance \u2013 Radius grid profile \u2013 Image profile Returns: radius ( float ) \u2013 Distance at which the profile matches the input value (same dimensionality of the distance input array)","title":"slow_get_radius()"},{"location":"api/utils/analysis.html#psftools.utils.analysis.slow_get_radius--remarks","text":"Only works for a monotonious profile","title":"Remarks"},{"location":"api/utils/deconvolution.html","text":"Deconvolution module \u00b6 Methods used for image deconvolution pcg_solver_single ( image , kernel , sigma , reg_parm = 0.0005 ) \u00b6 Solve equation A x = b using preconditioned conjugate gradient algorithm Parameters: image \u2013 kernel \u2013 sigma \u2013 reg_parm \u2013 Regularisation parameter for the inversion method Returns: deconvolved_image \u2013 The deconvolved image wiener_laplace ( image , psf , reg_fact , clip = True ) \u00b6 Deconvolution using a Wiener filter and high-freq penalization The signal is penalized by a 2D Laplacian operator that serves as a high-pass filter for the regularization process. Parameters: image \u2013 2D input array psf \u2013 2D kernel array reg_fact \u2013 Regularisation parameter for the inversion method clip \u2013 If True , enforces the non-amplification of the noise (default True ) Returns: deconv_image \u2013 2D deconvolved image wiener_reg ( image , psf , reg_fact , clip = False , clipfact = 1 ) \u00b6 Deconvolution using a Wiener filter Parameters: image \u2013 2D input array psf \u2013 2D kernel array reg_fact \u2013 Regularisation parameter for the inversion method clip \u2013 If True , enforces the non-amplification of the noise (default False ) clipfact \u2013 Level of the amplitude clipping (default 1) Returns: deconv_image \u2013 2D deconvolved image","title":"deconvolution"},{"location":"api/utils/deconvolution.html#psftools.utils.deconvolution--deconvolution-module","text":"Methods used for image deconvolution","title":"Deconvolution module"},{"location":"api/utils/deconvolution.html#psftools.utils.deconvolution.pcg_solver_single","text":"Solve equation A x = b using preconditioned conjugate gradient algorithm Parameters: image \u2013 kernel \u2013 sigma \u2013 reg_parm \u2013 Regularisation parameter for the inversion method Returns: deconvolved_image \u2013 The deconvolved image","title":"pcg_solver_single()"},{"location":"api/utils/deconvolution.html#psftools.utils.deconvolution.wiener_laplace","text":"Deconvolution using a Wiener filter and high-freq penalization The signal is penalized by a 2D Laplacian operator that serves as a high-pass filter for the regularization process. Parameters: image \u2013 2D input array psf \u2013 2D kernel array reg_fact \u2013 Regularisation parameter for the inversion method clip \u2013 If True , enforces the non-amplification of the noise (default True ) Returns: deconv_image \u2013 2D deconvolved image","title":"wiener_laplace()"},{"location":"api/utils/deconvolution.html#psftools.utils.deconvolution.wiener_reg","text":"Deconvolution using a Wiener filter Parameters: image \u2013 2D input array psf \u2013 2D kernel array reg_fact \u2013 Regularisation parameter for the inversion method clip \u2013 If True , enforces the non-amplification of the noise (default False ) clipfact \u2013 Level of the amplitude clipping (default 1) Returns: deconv_image \u2013 2D deconvolved image","title":"wiener_reg()"},{"location":"api/utils/fits.html","text":"Fits submodule \u00b6 Enables I/O operations with FITS files and headers create_fits ( image , hdr = None ) \u00b6 Create a basic fits file to store output data Parameters: image \u2013 Image data hdr \u2013 Header info for the image data (default None ) Returns: hdu \u2013 Image data embedded in a pyfits object with given or minimal header Notes \u00b6 If the input header is set to None , pyfits produces a minimal header to accompany the data. create_header ( image ) \u00b6 Create a basic header corresponding to the input data Parameters: image \u2013 Image data Returns: header \u2013 Header of the image load_fits_with_header ( filename ) \u00b6 Load data and header from a FITS file Parameters: filename \u2013 Name of input FITS file Returns: FITS data \u2013 FITS header \u2013 save_fits ( filepath , fitsfile , copy = True ) \u00b6 Save a FITS file Parameters: filepath \u2013 Name of output FITS file fitsfile \u2013 Image data embedded in a pyfits object copy \u2013 If True and file already existing, add a version number to the filename update_header_key ( header , key , value , comment = '' , verbose = False ) \u00b6 Update of add a given key of the image header Parameters: header \u2013 Header file key \u2013 Header key value \u2013 The value corresponding to the header key comment \u2013 Comment on the key / value (default '') verbose \u2013 Print information about the updated (default False ) write_fits ( filename , fitsdata , fitshdr = None ) \u00b6 Create and save basic fits file to store output data Parameters: filename \u2013 Name of output FITS file fitsdata \u2013 Image data fitshdr \u2013 Header info for the image data (default None ) Notes \u00b6 If the input header is set to None , pyfits produces a minimal header to accompany the data.","title":"fits"},{"location":"api/utils/fits.html#psftools.utils.fits--fits-submodule","text":"Enables I/O operations with FITS files and headers","title":"Fits submodule"},{"location":"api/utils/fits.html#psftools.utils.fits.create_fits","text":"Create a basic fits file to store output data Parameters: image \u2013 Image data hdr \u2013 Header info for the image data (default None ) Returns: hdu \u2013 Image data embedded in a pyfits object with given or minimal header","title":"create_fits()"},{"location":"api/utils/fits.html#psftools.utils.fits.create_fits--notes","text":"If the input header is set to None , pyfits produces a minimal header to accompany the data.","title":"Notes"},{"location":"api/utils/fits.html#psftools.utils.fits.create_header","text":"Create a basic header corresponding to the input data Parameters: image \u2013 Image data Returns: header \u2013 Header of the image","title":"create_header()"},{"location":"api/utils/fits.html#psftools.utils.fits.load_fits_with_header","text":"Load data and header from a FITS file Parameters: filename \u2013 Name of input FITS file Returns: FITS data \u2013 FITS header \u2013","title":"load_fits_with_header()"},{"location":"api/utils/fits.html#psftools.utils.fits.save_fits","text":"Save a FITS file Parameters: filepath \u2013 Name of output FITS file fitsfile \u2013 Image data embedded in a pyfits object copy \u2013 If True and file already existing, add a version number to the filename","title":"save_fits()"},{"location":"api/utils/fits.html#psftools.utils.fits.update_header_key","text":"Update of add a given key of the image header Parameters: header \u2013 Header file key \u2013 Header key value \u2013 The value corresponding to the header key comment \u2013 Comment on the key / value (default '') verbose \u2013 Print information about the updated (default False )","title":"update_header_key()"},{"location":"api/utils/fits.html#psftools.utils.fits.write_fits","text":"Create and save basic fits file to store output data Parameters: filename \u2013 Name of output FITS file fitsdata \u2013 Image data fitshdr \u2013 Header info for the image data (default None )","title":"write_fits()"},{"location":"api/utils/fits.html#psftools.utils.fits.write_fits--notes","text":"If the input header is set to None , pyfits produces a minimal header to accompany the data.","title":"Notes"},{"location":"api/utils/fitting.html","text":"Fitting submodule \u00b6 Classes and methods for fitting distributions of PSF images and characterizing them. AiryFit \u00b6 Bases: PSFfit Sub class of PSFfit dealing with Airy distributions GaussianFit \u00b6 Bases: PSFfit Sub class of PSFfit dealing with Gaussian distributions PSFfit \u00b6 Abstract class for fitting models to PSF data moments property \u00b6 Compute a first guess for the distribution parameters Uses the first moments of the data for position and width and sets the angle to 0. params property writable \u00b6 Get the current parameters of the distribution ee2radius ( percentage , norm_pix =- 1 ) \u00b6 Compute the radius corresponding to the given encercled energy (EE) Parameters: percentage \u2013 Percentage of energy encircled in the radius norm_pix \u2013 Index of the pixel used for the normalization of the integrated profile. (default -1 = last pixel) Returns: radius ( float ) \u2013 Radius encircling the given energy get_e1e2 () \u00b6 The real and imaginary components of the ellipticity get_ellipticity () \u00b6 The ellipticity is defined here as |epsilon| = (a - b) / (a + b), for a > b radius2ee ( hwhm_frac , norm_pix ) \u00b6 Compute the encercled energy corresponding to the given radius The radius here is defined as a fraction of the HWHW of the PSF. Parameters: hwhm_frac \u2013 Fraction of the HWHM norm_pix \u2013 Index of the pixel used for the normalization of the integrated profile. (default -1 = last pixel) Returns: ee ( float ) \u2013 Encircled energy","title":"fitting"},{"location":"api/utils/fitting.html#psftools.utils.fitting--fitting-submodule","text":"Classes and methods for fitting distributions of PSF images and characterizing them.","title":"Fitting submodule"},{"location":"api/utils/fitting.html#psftools.utils.fitting.AiryFit","text":"Bases: PSFfit Sub class of PSFfit dealing with Airy distributions","title":"AiryFit"},{"location":"api/utils/fitting.html#psftools.utils.fitting.GaussianFit","text":"Bases: PSFfit Sub class of PSFfit dealing with Gaussian distributions","title":"GaussianFit"},{"location":"api/utils/fitting.html#psftools.utils.fitting.PSFfit","text":"Abstract class for fitting models to PSF data","title":"PSFfit"},{"location":"api/utils/fitting.html#psftools.utils.fitting.PSFfit.moments","text":"Compute a first guess for the distribution parameters Uses the first moments of the data for position and width and sets the angle to 0.","title":"moments"},{"location":"api/utils/fitting.html#psftools.utils.fitting.PSFfit.params","text":"Get the current parameters of the distribution","title":"params"},{"location":"api/utils/fitting.html#psftools.utils.fitting.PSFfit.ee2radius","text":"Compute the radius corresponding to the given encercled energy (EE) Parameters: percentage \u2013 Percentage of energy encircled in the radius norm_pix \u2013 Index of the pixel used for the normalization of the integrated profile. (default -1 = last pixel) Returns: radius ( float ) \u2013 Radius encircling the given energy","title":"ee2radius()"},{"location":"api/utils/fitting.html#psftools.utils.fitting.PSFfit.get_e1e2","text":"The real and imaginary components of the ellipticity","title":"get_e1e2()"},{"location":"api/utils/fitting.html#psftools.utils.fitting.PSFfit.get_ellipticity","text":"The ellipticity is defined here as |epsilon| = (a - b) / (a + b), for a > b","title":"get_ellipticity()"},{"location":"api/utils/fitting.html#psftools.utils.fitting.PSFfit.radius2ee","text":"Compute the encercled energy corresponding to the given radius The radius here is defined as a fraction of the HWHW of the PSF. Parameters: hwhm_frac \u2013 Fraction of the HWHM norm_pix \u2013 Index of the pixel used for the normalization of the integrated profile. (default -1 = last pixel) Returns: ee ( float ) \u2013 Encircled energy","title":"radius2ee()"},{"location":"api/utils/fourier.html","text":"Fourier submodule \u00b6 Methods involving Fourier transform or the Fourier domain. + Wrapper methods for pyFFTW psf2otf ( psf , shape ) \u00b6 Convert point-spread function to optical transfer function. Compute the Fast Fourier Transform (FFT) of the point-spread function (PSF) array and creates the optical transfer function (OTF) array that is not influenced by the PSF off-centering. By default, the OTF array is the same size as the PSF array. To ensure that the OTF is not altered due to PSF off-centering, PSF2OTF post-pads the PSF array (down or to the right) with zeros to match dimensions specified in shape , then circularly shifts the values of the PSF array up (or to the left) until the central pixel reaches (1,1) position. Parameters: psf \u2013 Input PSF array shape ( tuple of int ) \u2013 Output shape of the OTF array Returns: otf \u2013 Output OTF array Notes \u00b6 Adapted from MATLAB psf2otf function pyfftw_builder ( image , method ) \u00b6 Compute the Fourier transform of an image using multithreading Parameters: image \u2013 Input image method \u2013 pyFFTW method Returns: fft_image ( complex ) \u2013 Fourier transform of input image ufft2 ( image ) \u00b6 Unitary fft2 uifft2 ( image ) \u00b6 Unitary ifft2","title":"fourier"},{"location":"api/utils/fourier.html#psftools.utils.fourier--fourier-submodule","text":"Methods involving Fourier transform or the Fourier domain. + Wrapper methods for pyFFTW","title":"Fourier submodule"},{"location":"api/utils/fourier.html#psftools.utils.fourier.psf2otf","text":"Convert point-spread function to optical transfer function. Compute the Fast Fourier Transform (FFT) of the point-spread function (PSF) array and creates the optical transfer function (OTF) array that is not influenced by the PSF off-centering. By default, the OTF array is the same size as the PSF array. To ensure that the OTF is not altered due to PSF off-centering, PSF2OTF post-pads the PSF array (down or to the right) with zeros to match dimensions specified in shape , then circularly shifts the values of the PSF array up (or to the left) until the central pixel reaches (1,1) position. Parameters: psf \u2013 Input PSF array shape ( tuple of int ) \u2013 Output shape of the OTF array Returns: otf \u2013 Output OTF array","title":"psf2otf()"},{"location":"api/utils/fourier.html#psftools.utils.fourier.psf2otf--notes","text":"Adapted from MATLAB psf2otf function","title":"Notes"},{"location":"api/utils/fourier.html#psftools.utils.fourier.pyfftw_builder","text":"Compute the Fourier transform of an image using multithreading Parameters: image \u2013 Input image method \u2013 pyFFTW method Returns: fft_image ( complex ) \u2013 Fourier transform of input image","title":"pyfftw_builder()"},{"location":"api/utils/fourier.html#psftools.utils.fourier.ufft2","text":"Unitary fft2","title":"ufft2()"},{"location":"api/utils/fourier.html#psftools.utils.fourier.uifft2","text":"Unitary ifft2","title":"uifft2()"},{"location":"api/utils/image.html","text":"Image submodule \u00b6 Various methods that operate on 2D images. center_distance ( size_x , size_y = 0 ) \u00b6 Return the pixel distance to the array center Parameters: size_x \u2013 Size along the x-axis of the square array size_y \u2013 Size along the y-axis if different from x (default 0) Returns: distance ( 2d ) \u2013 Euclidian distance (in pixels) from the center of the array center_psf ( image , order = 1 , verbose = False ) \u00b6 Shift the psf image to put the maximum at the center Parameters: image \u2013 Image array (PSF) order \u2013 interpolation order (default 1: bilinear) verbose \u2013 If True , allow for printed info (default False) Returns: shifted_image \u2013 Centered psf image with odd number of pixels on both axes centroid ( input , sigma , pixscl , n_iter = 3 ) \u00b6 Compute the image centroid iteratively with Gaussian weights. The weight is a circular two-dimensional Gaussian function centered on the first moments of the image at each iteration if the center is not specified as input. Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec pixscl \u2013 Pixel scale of the image to scale the Gaussian function n_iter \u2013 Number of iterations of the weighting (default 3) Returns: mu_x , mu_y \u2013 Coordinates of the cendroid in the image plane circularize ( image , n_iter = 14 , interp_order = 2 , log = False ) \u00b6 Circularize an image. Successively rotate the image and add it to itself with angles decreasing by a factor 2 every iteration. This is numerically equivalent to computing the average over 2^n rotations where n is the number of iterations. THe default choice of n_iter = 14 hence produces an image invariant under rotations of any angle that is a multiple of 360/2^14 = 360/16384 ~ 0.022 deg Parameters: image \u2013 Image to circularize n_iter \u2013 Number of iterations in the process (default 14) interp_order \u2013 Spline interpolation order in the rotation * 0 : linear * 1 : bilinear * 2 : bicubic (default) Returns: Circularized image \u2013 convolve ( image , kernel , verbose = False ) \u00b6 Convolution in real space using scipy ndimage library Parameters: image \u2013 image to be convolved kernel \u2013 convolution kernel verbose \u2013 if True, print information concerning the convolution process (default False) Returns: final_image \u2013 find_peak_position ( image , fit = False ) \u00b6 Basic implementation of a maximum position finder Parameters: image \u2013 Image array (PSF) fit \u2013 Fit a Gaussian distribution to the PSF and return center position (default False ) Returns: coords ( tuple of int ) \u2013 Position of the peak as a tuple of array indices first_moments ( input ) \u00b6 Compute the first moments (axis means) of the given image Parameters: input \u2013 Input image Returns: mu_x ( float ) \u2013 First moment on the x-axis mu_y ( float ) \u2013 First moment on the y-axis get_e1e2 ( input , sigma = 0.75 , pixscl = 0.1 , n_iter = 3 ) \u00b6 Compute the ellipticity components of the given image as the weighted second moments of the image. Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: e1 ( float ) \u2013 Real component of the ellipticity e2 ( float ) \u2013 Imaginary component of the ellipticity get_ellipticity ( input , sigma = 0.75 , pixscl = 0.1 , n_iter = 3 ) \u00b6 Compute the ellipticity the given image Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: ellipticity ( float ) \u2013 Ellipticity comprised between 0 and 1 get_major_minor_axes ( input , sigma = 0.75 , pixscl = 0.1 , n_iter = 3 ) \u00b6 Compute the major and minor axes of the given image from the quadrupole moments Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: a , b \u2013 Major and minor axes of the image get_r_squared ( input , sigma = 0.75 , pixscl = 0.1 , n_iter = 3 ) \u00b6 Compute R2 factor in arcseconds Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: r_squared ( float ) \u2013 R2 factor in arcseconds imresample ( image , input_pscale , target_pscale , interp_order = 1 ) \u00b6 Resample data array from one pixel scale to another Parameters: image \u2013 Input data array input_pscale ( float ) \u2013 Pixel scale of image in arcseconds target_pscale ( float ) \u2013 Pixel scale of output array in arcseconds interp_order ( int , optional ) \u2013 Spline interpolation order [0, 5] (default 1: linear) Returns: output \u2013 Resampled data array imrotate ( image , angle , reshape = False , interp_order = 1 ) \u00b6 Rotate image from North to East from the given angle in degrees Parameters: image \u2013 Data array angle ( float ) \u2013 Rotation angle in degrees reshape ( bool , optional ) \u2013 Whether the input array should be contained in the output one (default False) interp_order ( int , optional ) \u2013 Interpolation order [1-5] (default 1 = linear) Returns: output \u2013 Rotated data array interpolate_on_nan ( image ) \u00b6 Replaces NaNs by interpolated values on the given array merge_images ( core , tail , radius_transition ) \u00b6 Merge a core image with an analytic tail Parameters: core \u2013 Core image tail \u2013 Analytic tail radius_transition \u2013 Characteristic radius where the transition between core and tail occurs Returns: merged_image \u2013 The merged image mirror_pad ( image , pad_x , pad_y =- 1 ) \u00b6 Extends original 2d-image on every edge mirroring its content Parameters: image \u2013 Input image pad_x \u2013 The size of the padding in x-axis pad_y \u2013 The size of the y-axis padding if diff from x (default -1) Returns: img_pad \u2013 The padded image psf_peak_position ( image , crop_factor = 5 , n_iter = 5 ) \u00b6 Iterative finder of the position of the psf peak Parameters: image \u2013 Image array (PSF) crop_factor \u2013 Factor of image reduction for computational speed (default 5) n_iter \u2013 Number of maximum iterations in the smoothing process aimed at peak enhancement (default 5) Returns: coords ( tuple of ints ) \u2013 Coordinates of the peak in the input image remove_nan ( image ) \u00b6 Replaces NaNs by zeros in the given array second_moments ( input ) \u00b6 Compute the second moments of the given image Parameters: input \u2013 Input image Returns: q_xx , q_yy , q_xy \u2013 Second moments of the image trim ( image , shape , mask = None ) \u00b6 Trim image to a given shape Parameters: image \u2013 Input image shape \u2013 Desired output shape of the image mask \u2013 Mask corresponding to the desired values in the image. Should have a rectangular shape given as input. (defaut None ) Returns: new_image ( 2D ) \u2013 Input image trimmed weighted_second_moments ( input , sigma , pixscl , n_iter = 3 , center = None ) \u00b6 Compute iteratively the weighted second moments of the image. The weight is a circular two-dimensional Gaussian function centered on the first moments of the image at each iteration if the center is not specified as input. Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec pixscl \u2013 Pixel scale of the image to scale the Gaussian function n_iter \u2013 Number of iterations of the weighting (default 3) center \u2013 Fixed center for the Gaussian weight (default None ) Returns: Q_xx , Q_yy , Q_xy \u2013 Second moments (quadrupoles) of the image zero_pad ( image , shape , position = 'corner' , mask = False ) \u00b6 Extends image to a certain size with zeros Parameters: image \u2013 Input image shape \u2013 Desired output shape of the image mask \u2013 If True returns a mask corresponding to the position of the input image in the output one. (default False ) position ( str , optional ) \u2013 The position of the input image in the output one: * 'corner' top-left corner (default) * 'center' centered Returns: padded_img ( real ) \u2013 The zero-padded image [mask \u2013 The corresponding mask (if mask = True)]","title":"image"},{"location":"api/utils/image.html#psftools.utils.image--image-submodule","text":"Various methods that operate on 2D images.","title":"Image submodule"},{"location":"api/utils/image.html#psftools.utils.image.center_distance","text":"Return the pixel distance to the array center Parameters: size_x \u2013 Size along the x-axis of the square array size_y \u2013 Size along the y-axis if different from x (default 0) Returns: distance ( 2d ) \u2013 Euclidian distance (in pixels) from the center of the array","title":"center_distance()"},{"location":"api/utils/image.html#psftools.utils.image.center_psf","text":"Shift the psf image to put the maximum at the center Parameters: image \u2013 Image array (PSF) order \u2013 interpolation order (default 1: bilinear) verbose \u2013 If True , allow for printed info (default False) Returns: shifted_image \u2013 Centered psf image with odd number of pixels on both axes","title":"center_psf()"},{"location":"api/utils/image.html#psftools.utils.image.centroid","text":"Compute the image centroid iteratively with Gaussian weights. The weight is a circular two-dimensional Gaussian function centered on the first moments of the image at each iteration if the center is not specified as input. Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec pixscl \u2013 Pixel scale of the image to scale the Gaussian function n_iter \u2013 Number of iterations of the weighting (default 3) Returns: mu_x , mu_y \u2013 Coordinates of the cendroid in the image plane","title":"centroid()"},{"location":"api/utils/image.html#psftools.utils.image.circularize","text":"Circularize an image. Successively rotate the image and add it to itself with angles decreasing by a factor 2 every iteration. This is numerically equivalent to computing the average over 2^n rotations where n is the number of iterations. THe default choice of n_iter = 14 hence produces an image invariant under rotations of any angle that is a multiple of 360/2^14 = 360/16384 ~ 0.022 deg Parameters: image \u2013 Image to circularize n_iter \u2013 Number of iterations in the process (default 14) interp_order \u2013 Spline interpolation order in the rotation * 0 : linear * 1 : bilinear * 2 : bicubic (default) Returns: Circularized image \u2013","title":"circularize()"},{"location":"api/utils/image.html#psftools.utils.image.convolve","text":"Convolution in real space using scipy ndimage library Parameters: image \u2013 image to be convolved kernel \u2013 convolution kernel verbose \u2013 if True, print information concerning the convolution process (default False) Returns: final_image \u2013","title":"convolve()"},{"location":"api/utils/image.html#psftools.utils.image.find_peak_position","text":"Basic implementation of a maximum position finder Parameters: image \u2013 Image array (PSF) fit \u2013 Fit a Gaussian distribution to the PSF and return center position (default False ) Returns: coords ( tuple of int ) \u2013 Position of the peak as a tuple of array indices","title":"find_peak_position()"},{"location":"api/utils/image.html#psftools.utils.image.first_moments","text":"Compute the first moments (axis means) of the given image Parameters: input \u2013 Input image Returns: mu_x ( float ) \u2013 First moment on the x-axis mu_y ( float ) \u2013 First moment on the y-axis","title":"first_moments()"},{"location":"api/utils/image.html#psftools.utils.image.get_e1e2","text":"Compute the ellipticity components of the given image as the weighted second moments of the image. Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: e1 ( float ) \u2013 Real component of the ellipticity e2 ( float ) \u2013 Imaginary component of the ellipticity","title":"get_e1e2()"},{"location":"api/utils/image.html#psftools.utils.image.get_ellipticity","text":"Compute the ellipticity the given image Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: ellipticity ( float ) \u2013 Ellipticity comprised between 0 and 1","title":"get_ellipticity()"},{"location":"api/utils/image.html#psftools.utils.image.get_major_minor_axes","text":"Compute the major and minor axes of the given image from the quadrupole moments Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: a , b \u2013 Major and minor axes of the image","title":"get_major_minor_axes()"},{"location":"api/utils/image.html#psftools.utils.image.get_r_squared","text":"Compute R2 factor in arcseconds Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec (default 0.75) pixscl \u2013 Pixel scale of the image (default 0.1) n_iter \u2013 Number of iterations of the weighting (default 3) Returns: r_squared ( float ) \u2013 R2 factor in arcseconds","title":"get_r_squared()"},{"location":"api/utils/image.html#psftools.utils.image.imresample","text":"Resample data array from one pixel scale to another Parameters: image \u2013 Input data array input_pscale ( float ) \u2013 Pixel scale of image in arcseconds target_pscale ( float ) \u2013 Pixel scale of output array in arcseconds interp_order ( int , optional ) \u2013 Spline interpolation order [0, 5] (default 1: linear) Returns: output \u2013 Resampled data array","title":"imresample()"},{"location":"api/utils/image.html#psftools.utils.image.imrotate","text":"Rotate image from North to East from the given angle in degrees Parameters: image \u2013 Data array angle ( float ) \u2013 Rotation angle in degrees reshape ( bool , optional ) \u2013 Whether the input array should be contained in the output one (default False) interp_order ( int , optional ) \u2013 Interpolation order [1-5] (default 1 = linear) Returns: output \u2013 Rotated data array","title":"imrotate()"},{"location":"api/utils/image.html#psftools.utils.image.interpolate_on_nan","text":"Replaces NaNs by interpolated values on the given array","title":"interpolate_on_nan()"},{"location":"api/utils/image.html#psftools.utils.image.merge_images","text":"Merge a core image with an analytic tail Parameters: core \u2013 Core image tail \u2013 Analytic tail radius_transition \u2013 Characteristic radius where the transition between core and tail occurs Returns: merged_image \u2013 The merged image","title":"merge_images()"},{"location":"api/utils/image.html#psftools.utils.image.mirror_pad","text":"Extends original 2d-image on every edge mirroring its content Parameters: image \u2013 Input image pad_x \u2013 The size of the padding in x-axis pad_y \u2013 The size of the y-axis padding if diff from x (default -1) Returns: img_pad \u2013 The padded image","title":"mirror_pad()"},{"location":"api/utils/image.html#psftools.utils.image.psf_peak_position","text":"Iterative finder of the position of the psf peak Parameters: image \u2013 Image array (PSF) crop_factor \u2013 Factor of image reduction for computational speed (default 5) n_iter \u2013 Number of maximum iterations in the smoothing process aimed at peak enhancement (default 5) Returns: coords ( tuple of ints ) \u2013 Coordinates of the peak in the input image","title":"psf_peak_position()"},{"location":"api/utils/image.html#psftools.utils.image.remove_nan","text":"Replaces NaNs by zeros in the given array","title":"remove_nan()"},{"location":"api/utils/image.html#psftools.utils.image.second_moments","text":"Compute the second moments of the given image Parameters: input \u2013 Input image Returns: q_xx , q_yy , q_xy \u2013 Second moments of the image","title":"second_moments()"},{"location":"api/utils/image.html#psftools.utils.image.trim","text":"Trim image to a given shape Parameters: image \u2013 Input image shape \u2013 Desired output shape of the image mask \u2013 Mask corresponding to the desired values in the image. Should have a rectangular shape given as input. (defaut None ) Returns: new_image ( 2D ) \u2013 Input image trimmed","title":"trim()"},{"location":"api/utils/image.html#psftools.utils.image.weighted_second_moments","text":"Compute iteratively the weighted second moments of the image. The weight is a circular two-dimensional Gaussian function centered on the first moments of the image at each iteration if the center is not specified as input. Parameters: input \u2013 Input image sigma \u2013 Width of the weighting Gaussian in arcsec pixscl \u2013 Pixel scale of the image to scale the Gaussian function n_iter \u2013 Number of iterations of the weighting (default 3) center \u2013 Fixed center for the Gaussian weight (default None ) Returns: Q_xx , Q_yy , Q_xy \u2013 Second moments (quadrupoles) of the image","title":"weighted_second_moments()"},{"location":"api/utils/image.html#psftools.utils.image.zero_pad","text":"Extends image to a certain size with zeros Parameters: image \u2013 Input image shape \u2013 Desired output shape of the image mask \u2013 If True returns a mask corresponding to the position of the input image in the output one. (default False ) position ( str , optional ) \u2013 The position of the input image in the output one: * 'corner' top-left corner (default) * 'center' centered Returns: padded_img ( real ) \u2013 The zero-padded image [mask \u2013 The corresponding mask (if mask = True)]","title":"zero_pad()"},{"location":"api/utils/info.html","text":"Info submodule \u00b6 Info submodule \u00b6 Gather useful information on a PSF file","title":"info"},{"location":"api/utils/info.html#info-submodule","text":"","title":"Info submodule"},{"location":"api/utils/info.html#psftools.utils.info--info-submodule","text":"Gather useful information on a PSF file","title":"Info submodule"},{"location":"api/utils/misc.html","text":"Misc submodule \u00b6 Misc submodule \u00b6 Helper methods for use in various contexts. cart2pol ( x , y , unit = 'deg' ) \u00b6 Transform cartesian coordinates to polar Parameters: x ( float or ) \u2013 x-axis coordinate(s) y ( float or ) \u2013 y-axis coordinate(s) unit ( str , optional ) \u2013 Angle unit (default degrees 'deg') Returns: theta ( float or ) \u2013 Polar angle rho ( float or ) \u2013 Polar distance fwhm2sigma ( fwhm ) \u00b6 Convert the fwhm to a gaussian width pol2cart ( theta , rho , unit = 'deg' ) \u00b6 Transform polar coordinates to cartesian Parameters: theta ( float or ) \u2013 Polar angle rho ( float or ) \u2013 Polar distance unit ( str , optional ) \u2013 Angle unit (default degrees 'deg') Returns: x ( float or ) \u2013 x-axis coordinate(s) y ( float or ) \u2013 y-axis coordinate(s) print_help ( method , message , * args , ** kwargs ) \u00b6 Print wrapper to help debugging sigma2fwhm ( sigma ) \u00b6 Convert the gaussian width to a fwhm","title":"misc"},{"location":"api/utils/misc.html#misc-submodule","text":"","title":"Misc submodule"},{"location":"api/utils/misc.html#psftools.utils.misc--misc-submodule","text":"Helper methods for use in various contexts.","title":"Misc submodule"},{"location":"api/utils/misc.html#psftools.utils.misc.cart2pol","text":"Transform cartesian coordinates to polar Parameters: x ( float or ) \u2013 x-axis coordinate(s) y ( float or ) \u2013 y-axis coordinate(s) unit ( str , optional ) \u2013 Angle unit (default degrees 'deg') Returns: theta ( float or ) \u2013 Polar angle rho ( float or ) \u2013 Polar distance","title":"cart2pol()"},{"location":"api/utils/misc.html#psftools.utils.misc.fwhm2sigma","text":"Convert the fwhm to a gaussian width","title":"fwhm2sigma()"},{"location":"api/utils/misc.html#psftools.utils.misc.pol2cart","text":"Transform polar coordinates to cartesian Parameters: theta ( float or ) \u2013 Polar angle rho ( float or ) \u2013 Polar distance unit ( str , optional ) \u2013 Angle unit (default degrees 'deg') Returns: x ( float or ) \u2013 x-axis coordinate(s) y ( float or ) \u2013 y-axis coordinate(s)","title":"pol2cart()"},{"location":"api/utils/misc.html#psftools.utils.misc.print_help","text":"Print wrapper to help debugging","title":"print_help()"},{"location":"api/utils/misc.html#psftools.utils.misc.sigma2fwhm","text":"Convert the gaussian width to a fwhm","title":"sigma2fwhm()"},{"location":"api/utils/plotting.html","text":"Plotting submodule \u00b6 Plotting submodule \u00b6 Useful PSF plotting methods plot_image ( image , filepath , log = False , tridim = False , cmap = 'coolwarm' ) \u00b6 Creates plot of the current image Parameters: image ( real ) \u2013 Image to plot filepath ( str ) \u2013 Filename with full path log ( bool , optional ) \u2013 If True , plot the log scaled intensity. Only works for 2D plots. (default False ) tridim ( bool , optional ) \u2013 If True , renders as 3d instead of 2d (default False ) cmap ( str , optional ) \u2013 Colormap for the plot * 'gray' * 'jet' * 'coolwarm' (default) plot_log ( img , a = 1000 , cmap = 'CMRmap' ) \u00b6 Display the logarithmically stretched image Parameters: img ( array_like ) \u2013 image to display a ( float , optional ) \u2013 stretch factor (default 1000) cmap ( str , optional ) \u2013 colormap for the plot (any matplotlib colormap) (default 'CMRmap') plot_stretch ( img , scale = 'log' , cmap = 'Greys_r' , ** kwargs ) \u00b6 Display the stretched image using a given scale Parameters: img ( array_like ) \u2013 image to display scale ( str , optional ) \u2013 stretch scale * 'linear' * 'log' (default) * 'sqrt' * 'asinh' cmap ( str , optional ) \u2013 colormap for the plot (any matplotlib colormap) (default 'Greys_r')","title":"plotting"},{"location":"api/utils/plotting.html#plotting-submodule","text":"","title":"Plotting submodule"},{"location":"api/utils/plotting.html#psftools.utils.plotting--plotting-submodule","text":"Useful PSF plotting methods","title":"Plotting submodule"},{"location":"api/utils/plotting.html#psftools.utils.plotting.plot_image","text":"Creates plot of the current image Parameters: image ( real ) \u2013 Image to plot filepath ( str ) \u2013 Filename with full path log ( bool , optional ) \u2013 If True , plot the log scaled intensity. Only works for 2D plots. (default False ) tridim ( bool , optional ) \u2013 If True , renders as 3d instead of 2d (default False ) cmap ( str , optional ) \u2013 Colormap for the plot * 'gray' * 'jet' * 'coolwarm' (default)","title":"plot_image()"},{"location":"api/utils/plotting.html#psftools.utils.plotting.plot_log","text":"Display the logarithmically stretched image Parameters: img ( array_like ) \u2013 image to display a ( float , optional ) \u2013 stretch factor (default 1000) cmap ( str , optional ) \u2013 colormap for the plot (any matplotlib colormap) (default 'CMRmap')","title":"plot_log()"},{"location":"api/utils/plotting.html#psftools.utils.plotting.plot_stretch","text":"Display the stretched image using a given scale Parameters: img ( array_like ) \u2013 image to display scale ( str , optional ) \u2013 stretch scale * 'linear' * 'log' (default) * 'sqrt' * 'asinh' cmap ( str , optional ) \u2013 colormap for the plot (any matplotlib colormap) (default 'Greys_r')","title":"plot_stretch()"},{"location":"api/utils/profiles.html","text":"Profiles submodule \u00b6 PSF profiles submodule \u00b6 Common PSF analytic profiles and helper functions circ_gauss2d ( shape , xc , yc , sigma ) \u00b6 Circular 2d Gaussian function Parameters: shape \u2013 Shape of the output array xc \u2013 Center along the x-axis (column) yc \u2013 Center along the y-axis (row) sigma \u2013 Width of the Gaussian profile Returns: output \u2013 Image of a circurlar 2d Gaussian function gaussian ( radius , sigma ) \u00b6 Basic gaussian function with zero mean Parameters: radius \u2013 Input array of radial coordinates sigma \u2013 Standard deviation of the Gaussian profile Returns: profile \u2013 Radial profile corresponding to the input coordinates moffat ( radius , fwhm , beta ) \u00b6 Moffat optical PSF profile Parameters: radius \u2013 Input array of radial coordinates fwhm \u2013 Full width at half-maximum beta \u2013 Slope of the profile Returns: profile \u2013 Radial profile corresponding to the input coordinates psf_gaussian ( radius , fwhm ) \u00b6 Gaussian optical PSF Parameters: radius \u2013 Input array of radial coordinates fwhm \u2013 Full width at half-maximum Returns: profile \u2013 Radial profile corresponding to the input coordinates psf_moffat ( radius , fwhm ) \u00b6 PSF derived in Racine (1996) Parameters: radius \u2013 Input array of radial coordinates fwhm \u2013 Full width at half-maximums Returns: profile \u2013 Radial profile corresponding to the input coordinates","title":"profiles"},{"location":"api/utils/profiles.html#profiles-submodule","text":"","title":"Profiles submodule"},{"location":"api/utils/profiles.html#psftools.utils.profiles--psf-profiles-submodule","text":"Common PSF analytic profiles and helper functions","title":"PSF profiles submodule"},{"location":"api/utils/profiles.html#psftools.utils.profiles.circ_gauss2d","text":"Circular 2d Gaussian function Parameters: shape \u2013 Shape of the output array xc \u2013 Center along the x-axis (column) yc \u2013 Center along the y-axis (row) sigma \u2013 Width of the Gaussian profile Returns: output \u2013 Image of a circurlar 2d Gaussian function","title":"circ_gauss2d()"},{"location":"api/utils/profiles.html#psftools.utils.profiles.gaussian","text":"Basic gaussian function with zero mean Parameters: radius \u2013 Input array of radial coordinates sigma \u2013 Standard deviation of the Gaussian profile Returns: profile \u2013 Radial profile corresponding to the input coordinates","title":"gaussian()"},{"location":"api/utils/profiles.html#psftools.utils.profiles.moffat","text":"Moffat optical PSF profile Parameters: radius \u2013 Input array of radial coordinates fwhm \u2013 Full width at half-maximum beta \u2013 Slope of the profile Returns: profile \u2013 Radial profile corresponding to the input coordinates","title":"moffat()"},{"location":"api/utils/profiles.html#psftools.utils.profiles.psf_gaussian","text":"Gaussian optical PSF Parameters: radius \u2013 Input array of radial coordinates fwhm \u2013 Full width at half-maximum Returns: profile \u2013 Radial profile corresponding to the input coordinates","title":"psf_gaussian()"},{"location":"api/utils/profiles.html#psftools.utils.profiles.psf_moffat","text":"PSF derived in Racine (1996) Parameters: radius \u2013 Input array of radial coordinates fwhm \u2013 Full width at half-maximums Returns: profile \u2013 Radial profile corresponding to the input coordinates","title":"psf_moffat()"},{"location":"scripts/homogenize.html","text":"PSF homogenization (a.k.a. PSF matching) \u00b6 homogenize \u00b6 Perform a convolution of a FITS image with an homogenization kernel Usage \u00b6 homogenize.py [-h] [-v] [image] [-k [kernel]] [-o [outputfile]] [--real] [--numpy] Arguments \u00b6 image : path to FITS image to be homogenized Optionals \u00b6 -h , --help : print help -v : verbose-mode -k kernel : path to the convolution kernel -o output : provides the name of output FITS file --real : uses real-space convolution instead of Fourier-space","title":"homogenize"},{"location":"scripts/homogenize.html#psf-homogenization-aka-psf-matching","text":"","title":"PSF homogenization (a.k.a. PSF matching)"},{"location":"scripts/homogenize.html#psftools.scripts.homogenize--homogenize","text":"Perform a convolution of a FITS image with an homogenization kernel","title":"homogenize"},{"location":"scripts/homogenize.html#psftools.scripts.homogenize--usage","text":"homogenize.py [-h] [-v] [image] [-k [kernel]] [-o [outputfile]] [--real] [--numpy]","title":"Usage"},{"location":"scripts/homogenize.html#psftools.scripts.homogenize--arguments","text":"image : path to FITS image to be homogenized","title":"Arguments"},{"location":"scripts/homogenize.html#psftools.scripts.homogenize--optionals","text":"-h , --help : print help -v : verbose-mode -k kernel : path to the convolution kernel -o output : provides the name of output FITS file --real : uses real-space convolution instead of Fourier-space","title":"Optionals"},{"location":"scripts/make_kernel.html","text":"Create homogenization kernel \u00b6 The goal of this script is given two PSFs \\(P_1\\) and \\(P_2\\) with \\({\\rm fwhm}({P_1}) < {\\rm fwhm}({P_2})\\) , compute the kernel \\(K\\) such that \\[P_2 = K \\ast P_1\\] If you are interested in this, please have a look at the pypher program available here and references therein. make_kernel \u00b6 Compute the transition kernel between two PSFs It takes two images (FITS files) as input, a high-frequencies The computation of the kernel uses deconvolution with a Wiener filter where the high-frequencies of the image (noise) are penalized by a Laplacian filter, at an amplitude given by the input regularization parameter. Alternatively, the user can decide to use the Aniano recipe (circularization + high-frequency filtering) by passing the --aniano keyword. Usage \u00b6 make_kernel [-h] [psf_input] [psf_target] [-o [output]] [-p [pixel_scale]] [--angle_input] [--angle_target] [-R [regfact]] [-A, --aniano] [-m, --minimize] [-v, --verbose] Arguments \u00b6 psf_input : path to the input PSF (FITS image) psf_target : path to the low resolution PSF (FITS image) -o output : the output filename and path -p pixel_scale : pixel scale of the output fits in arcsec Optionals \u00b6 -h , --help : print help --angle_input : rotate image from North to East given the angle in degrees (default 0.0) --angle_target : rotate image from North to East given the angle in degrees (default 0.0) -R , --regfact : regularization factor (default 1e-5) -A , --aniano : use the Aniano method instead of Wiener filtering (default False) -m , --minimize : minimize the size of the output kernel (default False) (currently unavailable) -v , --verbose : print information while running the script (default False) compute_bayesian_kernel ( psf_input , psf_target , sigma = 1 , reg_fact = 0.0005 ) \u00b6 Compute the kernel using bayesian methods Parameters: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF Returns: kernel \u2013 Output circular kernel header ( fits . Header ) \u2013 Kernel header freshly formatted Notes \u00b6 Solves the system y = H(x) + n where x is the desired kernel and n is the noise using preconditioned conjugate gradient compute_circular_kernel ( psf_input , psf_target ) \u00b6 Compute the kernel using circularization Parameters: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF Returns: kernel \u2013 Output circular kernel header ( fits . Header ) \u2013 Kernel header freshly formatted compute_wiener_kernel ( psf_input , psf_target , reg_fact ) \u00b6 Compute the kernel using Wiener filtering Parameters: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF reg_fact \u2013 Regularization factor for the inversion Returns: kernel \u2013 Output circular kernel header ( fits . Header ) \u2013 Kernel header freshly formatted Notes \u00b6 Solves the system y = H(x) + n where x is the desired kernel and n is the noise using a Wiener filtering method with regularization and a high-pass penalization (Laplacian) init_fits_and_header ( kernel , args ) \u00b6 Format the output kernel header along with FITS data Parameters: kernel \u2013 The real space convolution kernel Returns: header \u2013 Output kernel formatted FITS minimize_psf_size ( kernel , header ) \u00b6 Trim the kernel to keep an array containing 99.9% of its energy Parameters: kernel \u2013 The real space convolution kernel Returns: kernel_reduced \u2013 A trimmed version of the kernel parse_args () \u00b6 Command-line parser prepare_input_psfs ( args ) \u00b6 Compute preliminary steps for kernel computation Parameters: args \u2013 Namespace with input information stored Returns: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF","title":"make_kernel"},{"location":"scripts/make_kernel.html#create-homogenization-kernel","text":"The goal of this script is given two PSFs \\(P_1\\) and \\(P_2\\) with \\({\\rm fwhm}({P_1}) < {\\rm fwhm}({P_2})\\) , compute the kernel \\(K\\) such that \\[P_2 = K \\ast P_1\\] If you are interested in this, please have a look at the pypher program available here and references therein.","title":"Create homogenization kernel"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel--make_kernel","text":"Compute the transition kernel between two PSFs It takes two images (FITS files) as input, a high-frequencies The computation of the kernel uses deconvolution with a Wiener filter where the high-frequencies of the image (noise) are penalized by a Laplacian filter, at an amplitude given by the input regularization parameter. Alternatively, the user can decide to use the Aniano recipe (circularization + high-frequency filtering) by passing the --aniano keyword.","title":"make_kernel"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel--usage","text":"make_kernel [-h] [psf_input] [psf_target] [-o [output]] [-p [pixel_scale]] [--angle_input] [--angle_target] [-R [regfact]] [-A, --aniano] [-m, --minimize] [-v, --verbose]","title":"Usage"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel--arguments","text":"psf_input : path to the input PSF (FITS image) psf_target : path to the low resolution PSF (FITS image) -o output : the output filename and path -p pixel_scale : pixel scale of the output fits in arcsec","title":"Arguments"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel--optionals","text":"-h , --help : print help --angle_input : rotate image from North to East given the angle in degrees (default 0.0) --angle_target : rotate image from North to East given the angle in degrees (default 0.0) -R , --regfact : regularization factor (default 1e-5) -A , --aniano : use the Aniano method instead of Wiener filtering (default False) -m , --minimize : minimize the size of the output kernel (default False) (currently unavailable) -v , --verbose : print information while running the script (default False)","title":"Optionals"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.compute_bayesian_kernel","text":"Compute the kernel using bayesian methods Parameters: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF Returns: kernel \u2013 Output circular kernel header ( fits . Header ) \u2013 Kernel header freshly formatted","title":"compute_bayesian_kernel()"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.compute_bayesian_kernel--notes","text":"Solves the system y = H(x) + n where x is the desired kernel and n is the noise using preconditioned conjugate gradient","title":"Notes"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.compute_circular_kernel","text":"Compute the kernel using circularization Parameters: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF Returns: kernel \u2013 Output circular kernel header ( fits . Header ) \u2013 Kernel header freshly formatted","title":"compute_circular_kernel()"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.compute_wiener_kernel","text":"Compute the kernel using Wiener filtering Parameters: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF reg_fact \u2013 Regularization factor for the inversion Returns: kernel \u2013 Output circular kernel header ( fits . Header ) \u2013 Kernel header freshly formatted","title":"compute_wiener_kernel()"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.compute_wiener_kernel--notes","text":"Solves the system y = H(x) + n where x is the desired kernel and n is the noise using a Wiener filtering method with regularization and a high-pass penalization (Laplacian)","title":"Notes"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.init_fits_and_header","text":"Format the output kernel header along with FITS data Parameters: kernel \u2013 The real space convolution kernel Returns: header \u2013 Output kernel formatted FITS","title":"init_fits_and_header()"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.minimize_psf_size","text":"Trim the kernel to keep an array containing 99.9% of its energy Parameters: kernel \u2013 The real space convolution kernel Returns: kernel_reduced \u2013 A trimmed version of the kernel","title":"minimize_psf_size()"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.parse_args","text":"Command-line parser","title":"parse_args()"},{"location":"scripts/make_kernel.html#psftools.scripts.make_kernel.prepare_input_psfs","text":"Compute preliminary steps for kernel computation Parameters: args \u2013 Namespace with input information stored Returns: psf_input \u2013 PSF object for the high res PSF psf_target \u2013 PSF object for the low res PSF","title":"prepare_input_psfs()"}]}